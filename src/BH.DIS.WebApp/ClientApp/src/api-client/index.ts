//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import * as moment from 'moment';

export class AuthClient {
  constructor(private apiUrl?: string, private accessToken?: string) {}

  getBaseUrl(
    defaultUrl: string | undefined,
    requestedUrl?: string | undefined
  ): string {
    return requestedUrl ? requestedUrl : this.apiUrl ?? "";
  }

  transformHttpRequestOptions(options: RequestInit): Promise<RequestInit> {
    if (options.headers && this.accessToken) {
      options.headers = {
        ...options.headers,
        Authorization: "Bearer " + this.accessToken,
      };
    }

    return Promise.resolve(options);
  }
}

export class ApiClientBase {
  constructor(private authClient: AuthClient) {}

  getBaseUrl(_: string | undefined, defaultUrl: string | undefined): string {
    return this.authClient
      ? this.authClient.getBaseUrl(defaultUrl)
      : defaultUrl!;
  }

  transformOptions(options: RequestInit): Promise<RequestInit> {
    if (!options.headers) {
      options.headers = {};
    }
    options.headers = { ...options.headers, "api-version": "2" };
    const isIE = navigator.userAgent.indexOf("Trident/") !== -1;
    if (
      isIE &&
      (options.method === undefined ||
        options.method === "GET" ||
        options.method === "HEAD")
    ) {
      options.cache = "no-cache";
      options.headers = {
        ...options.headers,
        "X-IE-Cache-Bust": new Date().getTime().toString(),
      };
    }
    return this.authClient
      ? this.authClient.transformHttpRequestOptions(options)
      : Promise.resolve(options);
  }
}

export class Client extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get current status of all endpoints
     * @return Successfully returned endpoint statuses
     */
    getEndpointStatusCountAll(): Promise<EndpointStatusCount[]> {
        let url_ = this.baseUrl + "/api/endpoint/status/count";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEndpointStatusCountAll(_response);
        });
    }

    protected processGetEndpointStatusCountAll(response: Response): Promise<EndpointStatusCount[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EndpointStatusCount.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EndpointStatusCount[]>(null as any);
    }

    /**
     * Get current status of specific endpoints
     * @param body (optional) 
     * @return OK
     */
    postApiEndpointStatusCount(body?: string[] | undefined): Promise<EndpointStatusCount[]> {
        let url_ = this.baseUrl + "/api/endpoint/status/count";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostApiEndpointStatusCount(_response);
        });
    }

    protected processPostApiEndpointStatusCount(response: Response): Promise<EndpointStatusCount[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EndpointStatusCount.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EndpointStatusCount[]>(null as any);
    }

    /**
     * Get endpoint status
     * @param endpointName Name of the endpoint
     * @return Dictionary of all the Unresolved Events for the endpoint, or an empty object if no Unresolved Events.
     */
    getEndpointStatusId(endpointName: string): Promise<Event[]> {
        let url_ = this.baseUrl + "/api/endpoint/{endpointName}/status/";
        if (endpointName === undefined || endpointName === null)
            throw new Error("The parameter 'endpointName' must be defined.");
        url_ = url_.replace("{endpointName}", encodeURIComponent("" + endpointName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEndpointStatusId(_response);
        });
    }

    protected processGetEndpointStatusId(response: Response): Promise<Event[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Event.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Endpoint not found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Event[]>(null as any);
    }

    /**
     * Storage webhook configuration options
     * @param webHook_Request_Origin (optional) 
     * @param webHook_Request_Callback (optional) 
     * @param webHook_Request_Rate (optional) 
     * @return OK
     */
    storagehookOptions(webHook_Request_Origin?: string | undefined, webHook_Request_Callback?: string | undefined, webHook_Request_Rate?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/storagehook";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "OPTIONS",
            headers: {
                "WebHook-Request-Origin": webHook_Request_Origin !== undefined && webHook_Request_Origin !== null ? "" + webHook_Request_Origin : "",
                "WebHook-Request-Callback": webHook_Request_Callback !== undefined && webHook_Request_Callback !== null ? "" + webHook_Request_Callback : "",
                "WebHook-Request-Rate": webHook_Request_Rate !== undefined && webHook_Request_Rate !== null ? "" + webHook_Request_Rate : "",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processStoragehookOptions(_response);
        });
    }

    protected processStoragehookOptions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Post EventGrid event
     * @param aeg_event_type (optional) 
     * @return OK
     */
    storagehookReceive(body: any[], aeg_event_type?: AegEventType | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/storagehook";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "aeg-event-type": aeg_event_type !== undefined && aeg_event_type !== null ? "" + aeg_event_type : "",
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processStoragehookReceive(_response);
        });
    }

    protected processStoragehookReceive(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Your GET endpoint
     * @return OK
     */
    getEventIds(eventId: string, messageId: string): Promise<Message> {
        let url_ = this.baseUrl + "/api/event/{eventId}/{messageId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEventIds(_response);
        });
    }

    protected processGetEventIds(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    /**
     * Your GET endpoint
     * @return OK
     */
    getUnresolvedFailedEventId(endpointId: string, eventId: string, sessionId: string): Promise<Event> {
        let url_ = this.baseUrl + "/api/event/unresolved/{endpointId}/{eventId}/{sessionId}";
        if (endpointId === undefined || endpointId === null)
            throw new Error("The parameter 'endpointId' must be defined.");
        url_ = url_.replace("{endpointId}", encodeURIComponent("" + endpointId));
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        if (sessionId === undefined || sessionId === null)
            throw new Error("The parameter 'sessionId' must be defined.");
        url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUnresolvedFailedEventId(_response);
        });
    }

    protected processGetUnresolvedFailedEventId(response: Response): Promise<Event> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Event.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Event>(null as any);
    }

    /**
     * GetEventTypes
     * @return OK
     */
    getEventTypes(): Promise<EventType[]> {
        let url_ = this.baseUrl + "/api/event-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEventTypes(_response);
        });
    }

    protected processGetEventTypes(response: Response): Promise<EventType[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EventType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EventType[]>(null as any);
    }

    /**
     * Your GET endpoint
     * @return OK
     */
    getEventtypesEventtypeid(eventtypeid: string): Promise<EventTypeDetails> {
        let url_ = this.baseUrl + "/api/event-types/{eventtypeid}";
        if (eventtypeid === undefined || eventtypeid === null)
            throw new Error("The parameter 'eventtypeid' must be defined.");
        url_ = url_.replace("{eventtypeid}", encodeURIComponent("" + eventtypeid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEventtypesEventtypeid(_response);
        });
    }

    protected processGetEventtypesEventtypeid(response: Response): Promise<EventTypeDetails> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventTypeDetails.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EventTypeDetails>(null as any);
    }

    /**
     * @return OK
     */
    postResubmitEventIds(eventId: string, messageId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/event/resubmit/{eventId}/{messageId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostResubmitEventIds(_response);
        });
    }

    protected processPostResubmitEventIds(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Created", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    postSkipEventIds(eventId: string, messageId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/event/skip/{eventId}/{messageId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostSkipEventIds(_response);
        });
    }

    protected processPostSkipEventIds(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Your GET endpoint
     * @return OK
     */
    getApiEndpointstatusStatusEndpointName(endpointName: string): Promise<EndpointStatus> {
        let url_ = this.baseUrl + "/api/endpointREVIST/status/{endpointName}";
        if (endpointName === undefined || endpointName === null)
            throw new Error("The parameter 'endpointName' must be defined.");
        url_ = url_.replace("{endpointName}", encodeURIComponent("" + endpointName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetApiEndpointstatusStatusEndpointName(_response);
        });
    }

    protected processGetApiEndpointstatusStatusEndpointName(response: Response): Promise<EndpointStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EndpointStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EndpointStatus>(null as any);
    }

    /**
     * Your GET endpoint
     * @return OK
     */
    getEventDetailsId(id: string, endpoint: string): Promise<EventDetails> {
        let url_ = this.baseUrl + "/api/event/details/{endpoint}/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (endpoint === undefined || endpoint === null)
            throw new Error("The parameter 'endpoint' must be defined.");
        url_ = url_.replace("{endpoint}", encodeURIComponent("" + endpoint));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEventDetailsId(_response);
        });
    }

    protected processGetEventDetailsId(response: Response): Promise<EventDetails> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventDetails.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EventDetails>(null as any);
    }

    /**
     * Your GET endpoint
     * @return OK
     */
    getEventId(id: string, endpoint: string): Promise<Event> {
        let url_ = this.baseUrl + "/api/event/cosmos-details/{endpoint}/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (endpoint === undefined || endpoint === null)
            throw new Error("The parameter 'endpoint' must be defined.");
        url_ = url_.replace("{endpoint}", encodeURIComponent("" + endpoint));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEventId(_response);
        });
    }

    protected processGetEventId(response: Response): Promise<Event> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Event.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Event>(null as any);
    }

    /**
     * Your GET endpoint
     * @return OK
     */
    getEventtypesByEndpointId(endpointId: string): Promise<Anonymous> {
        let url_ = this.baseUrl + "/api/event-types/endpoint/{endpointId}";
        if (endpointId === undefined || endpointId === null)
            throw new Error("The parameter 'endpointId' must be defined.");
        url_ = url_.replace("{endpointId}", encodeURIComponent("" + endpointId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEventtypesByEndpointId(_response);
        });
    }

    protected processGetEventtypesByEndpointId(response: Response): Promise<Anonymous> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Anonymous.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    postResubmitWithChangesEventIds(eventId: string, messageId: string, body?: ResubmitWithChanges | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/event/change/{eventId}/{messageId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostResubmitWithChangesEventIds(_response);
        });
    }

    protected processPostResubmitWithChangesEventIds(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Your GET endpoint
     * @return OK
     */
    getApiAppStats(): Promise<ApplicationStatus> {
        let url_ = this.baseUrl + "/api/app/stats";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetApiAppStats(_response);
        });
    }

    protected processGetApiAppStats(response: Response): Promise<ApplicationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationStatus>(null as any);
    }

    /**
     * Your GET endpoint
     * @return OK
     */
    getEndpointsAll(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/endpoint/endpoints";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEndpointsAll(_response);
        });
    }

    protected processGetEndpointsAll(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * Get EndpointStatus Count
     * @return OK
     */
    getEndpointStatusCountId(endpointName: string): Promise<EndpointStatusCount> {
        let url_ = this.baseUrl + "/api/endpoint/{endpointName}/status/count";
        if (endpointName === undefined || endpointName === null)
            throw new Error("The parameter 'endpointName' must be defined.");
        url_ = url_.replace("{endpointName}", encodeURIComponent("" + endpointName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEndpointStatusCountId(_response);
        });
    }

    protected processGetEndpointStatusCountId(response: Response): Promise<EndpointStatusCount> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EndpointStatusCount.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EndpointStatusCount>(null as any);
    }

    /**
     * Your POST endpoint
     * @param body (optional) 
     * @return OK
     */
    postEndpointStatusIdToken(endpointName: string, body?: ContinuationToken | undefined): Promise<EndpointStatus> {
        let url_ = this.baseUrl + "/api/endpoint/{endpointName}/status/continuationToken";
        if (endpointName === undefined || endpointName === null)
            throw new Error("The parameter 'endpointName' must be defined.");
        url_ = url_.replace("{endpointName}", encodeURIComponent("" + endpointName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostEndpointStatusIdToken(_response);
        });
    }

    protected processPostEndpointStatusIdToken(response: Response): Promise<EndpointStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EndpointStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EndpointStatus>(null as any);
    }

    /**
     * Your GET endpoint
     * @return OK
     */
    getEventDetailsLogsId(id: string, endpointId: string): Promise<EventLogEntry[]> {
        let url_ = this.baseUrl + "/api/event/details/{endpointId}/{id}/logs";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (endpointId === undefined || endpointId === null)
            throw new Error("The parameter 'endpointId' must be defined.");
        url_ = url_.replace("{endpointId}", encodeURIComponent("" + endpointId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEventDetailsLogsId(_response);
        });
    }

    protected processGetEventDetailsLogsId(response: Response): Promise<EventLogEntry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EventLogEntry.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EventLogEntry[]>(null as any);
    }

    /**
     * Your GET endpoint
     * @return OK
     */
    getEventDetailsHistoryId(id: string, endpointId: string): Promise<Message[]> {
        let url_ = this.baseUrl + "/api/event/details/{endpointId}/{id}/history";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (endpointId === undefined || endpointId === null)
            throw new Error("The parameter 'endpointId' must be defined.");
        url_ = url_.replace("{endpointId}", encodeURIComponent("" + endpointId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEventDetailsHistoryId(_response);
        });
    }

    protected processGetEventDetailsHistoryId(response: Response): Promise<Message[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Message.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message[]>(null as any);
    }

    /**
     * Your GET endpoint
     * @return OK
     */
    getEndpointSessionId(endpointId: string, sessionId: string): Promise<SessionStatus> {
        let url_ = this.baseUrl + "/api/endpoint/{endpointId}/session/{sessionId}";
        if (endpointId === undefined || endpointId === null)
            throw new Error("The parameter 'endpointId' must be defined.");
        url_ = url_.replace("{endpointId}", encodeURIComponent("" + endpointId));
        if (sessionId === undefined || sessionId === null)
            throw new Error("The parameter 'sessionId' must be defined.");
        url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEndpointSessionId(_response);
        });
    }

    protected processGetEndpointSessionId(response: Response): Promise<SessionStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SessionStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SessionStatus>(null as any);
    }

    /**
     * @return OK
     */
    storagehookReceiveCosmos(endpointId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/storagehook/cosmos/{endpointId}";
        if (endpointId === undefined || endpointId === null)
            throw new Error("The parameter 'endpointId' must be defined.");
        url_ = url_.replace("{endpointId}", encodeURIComponent("" + endpointId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processStoragehookReceiveCosmos(_response);
        });
    }

    protected processStoragehookReceiveCosmos(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Your GET endpoint
     * @return OK
     */
    getMessageAuditsEventId(eventId: string): Promise<MessageAudit[]> {
        let url_ = this.baseUrl + "/api/event/audit/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMessageAuditsEventId(_response);
        });
    }

    protected processGetMessageAuditsEventId(response: Response): Promise<MessageAudit[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MessageAudit.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Created", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MessageAudit[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    postMessageAudit(eventId: string, body?: MessageAudit | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/event/audit/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostMessageAudit(_response);
        });
    }

    protected processPostMessageAudit(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Your POST endpoint
     * @param body (optional) 
     * @return OK
     */
    postComposeNewEvent(body?: ResubmitWithChanges | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/event/compose-new";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostComposeNewEvent(_response);
        });
    }

    protected processPostComposeNewEvent(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Your GET endpoint
     * @return OK
     */
    getEventBlockedId(endpointId: string, sessionId: string): Promise<BlockedEvent[]> {
        let url_ = this.baseUrl + "/api/event/blocked/{endpointId}/{sessionId}";
        if (endpointId === undefined || endpointId === null)
            throw new Error("The parameter 'endpointId' must be defined.");
        url_ = url_.replace("{endpointId}", encodeURIComponent("" + endpointId));
        if (sessionId === undefined || sessionId === null)
            throw new Error("The parameter 'sessionId' must be defined.");
        url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEventBlockedId(_response);
        });
    }

    protected processGetEventBlockedId(response: Response): Promise<BlockedEvent[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BlockedEvent.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BlockedEvent[]>(null as any);
    }

    /**
     * Your GET endpoint
     * @return OK
     */
    getEventPendingId(endpointId: string): Promise<Event[]> {
        let url_ = this.baseUrl + "/api/event/pending/{endpointId}";
        if (endpointId === undefined || endpointId === null)
            throw new Error("The parameter 'endpointId' must be defined.");
        url_ = url_.replace("{endpointId}", encodeURIComponent("" + endpointId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEventPendingId(_response);
        });
    }

    protected processGetEventPendingId(response: Response): Promise<Event[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Event.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Event[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    postEndpointSubscribe(endpointId: string, body?: EndpointSubscription | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/endpoint/{endpointId}/subscribe";
        if (endpointId === undefined || endpointId === null)
            throw new Error("The parameter 'endpointId' must be defined.");
        url_ = url_.replace("{endpointId}", encodeURIComponent("" + endpointId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostEndpointSubscribe(_response);
        });
    }

    protected processPostEndpointSubscribe(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getEndpointSubscribe(endpointId: string): Promise<EndpointSubscription[]> {
        let url_ = this.baseUrl + "/api/endpoint/{endpointId}/subscribe";
        if (endpointId === undefined || endpointId === null)
            throw new Error("The parameter 'endpointId' must be defined.");
        url_ = url_.replace("{endpointId}", encodeURIComponent("" + endpointId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEndpointSubscribe(_response);
        });
    }

    protected processGetEndpointSubscribe(response: Response): Promise<EndpointSubscription[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EndpointSubscription.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EndpointSubscription[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteEndpointSubscribe(endpointId: string, body?: SubscriptionAuthor | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/endpoint/{endpointId}/subscribe";
        if (endpointId === undefined || endpointId === null)
            throw new Error("The parameter 'endpointId' must be defined.");
        url_ = url_.replace("{endpointId}", encodeURIComponent("" + endpointId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteEndpointSubscribe(_response);
        });
    }

    protected processDeleteEndpointSubscribe(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    postEndpointPurge(endpointName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/endpoint/{endpointName}/purge";
        if (endpointName === undefined || endpointName === null)
            throw new Error("The parameter 'endpointName' must be defined.");
        url_ = url_.replace("{endpointName}", encodeURIComponent("" + endpointName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostEndpointPurge(_response);
        });
    }

    protected processPostEndpointPurge(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    postEndpointSubscriptionstatus(endpointId: string, body?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/endpoint/{endpointId}/subscriptionstatus";
        if (endpointId === undefined || endpointId === null)
            throw new Error("The parameter 'endpointId' must be defined.");
        url_ = url_.replace("{endpointId}", encodeURIComponent("" + endpointId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostEndpointSubscriptionstatus(_response);
        });
    }

    protected processPostEndpointSubscriptionstatus(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getEndpointSubscriptionstatus(endpointId: string): Promise<string> {
        let url_ = this.baseUrl + "/api/endpoint/{endpointId}/subscriptionstatus";
        if (endpointId === undefined || endpointId === null)
            throw new Error("The parameter 'endpointId' must be defined.");
        url_ = url_.replace("{endpointId}", encodeURIComponent("" + endpointId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEndpointSubscriptionstatus(_response);
        });
    }

    protected processGetEndpointSubscriptionstatus(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    endpointEnableHeartbeat(endpointId: string, body?: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/endpoint/{endpointId}/enableheartbeat";
        if (endpointId === undefined || endpointId === null)
            throw new Error("The parameter 'endpointId' must be defined.");
        url_ = url_.replace("{endpointId}", encodeURIComponent("" + endpointId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processEndpointEnableHeartbeat(_response);
        });
    }

    protected processEndpointEnableHeartbeat(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    deleteEventInvalidId(endpointId: string, eventId: string, sessionId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/event/invalid/{endpointId}/{eventId}/{sessionId}";
        if (endpointId === undefined || endpointId === null)
            throw new Error("The parameter 'endpointId' must be defined.");
        url_ = url_.replace("{endpointId}", encodeURIComponent("" + endpointId));
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        if (sessionId === undefined || sessionId === null)
            throw new Error("The parameter 'sessionId' must be defined.");
        url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteEventInvalidId(_response);
        });
    }

    protected processDeleteEventInvalidId(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Your GET endpoint
     * @return OK
     */
    getEndpointRoleAssignmentScript(endpointId: string): Promise<string> {
        let url_ = this.baseUrl + "/api/endpoint/{endpointId}/roleAssignmentScript";
        if (endpointId === undefined || endpointId === null)
            throw new Error("The parameter 'endpointId' must be defined.");
        url_ = url_.replace("{endpointId}", encodeURIComponent("" + endpointId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEndpointRoleAssignmentScript(_response);
        });
    }

    protected processGetEndpointRoleAssignmentScript(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Your GET endpoint
     * @return OK
     */
    getEventUnsupportedEndpointIdEventId(endpointId: string, eventId: string, sessionId: string): Promise<Event> {
        let url_ = this.baseUrl + "/api/event/unsupported/{endpointId}/{eventId}/{sessionId}";
        if (endpointId === undefined || endpointId === null)
            throw new Error("The parameter 'endpointId' must be defined.");
        url_ = url_.replace("{endpointId}", encodeURIComponent("" + endpointId));
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        if (sessionId === undefined || sessionId === null)
            throw new Error("The parameter 'sessionId' must be defined.");
        url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEventUnsupportedEndpointIdEventId(_response);
        });
    }

    protected processGetEventUnsupportedEndpointIdEventId(response: Response): Promise<Event> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Event.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Event>(null as any);
    }

    /**
     * Your GET endpoint
     * @return OK
     */
    getEventDeadletterEndpointIdEventId(endpointId: string, eventId: string, sessionId: string): Promise<Event> {
        let url_ = this.baseUrl + "/api/event/deadletter/{endpointId}/{eventId}/{sessionId}";
        if (endpointId === undefined || endpointId === null)
            throw new Error("The parameter 'endpointId' must be defined.");
        url_ = url_.replace("{endpointId}", encodeURIComponent("" + endpointId));
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        if (sessionId === undefined || sessionId === null)
            throw new Error("The parameter 'sessionId' must be defined.");
        url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEventDeadletterEndpointIdEventId(_response);
        });
    }

    protected processGetEventDeadletterEndpointIdEventId(response: Response): Promise<Event> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Event.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Event>(null as any);
    }

    /**
     * @param body (optional) getByFilterBody
     * @return OK
     */
    postApiEventEndpointIdGetByFilter(endpointId: string, body?: SearchRequest | undefined): Promise<SearchResponse> {
        let url_ = this.baseUrl + "/api/event/{endpointId}/getByFilter";
        if (endpointId === undefined || endpointId === null)
            throw new Error("The parameter 'endpointId' must be defined.");
        url_ = url_.replace("{endpointId}", encodeURIComponent("" + endpointId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostApiEventEndpointIdGetByFilter(_response);
        });
    }

    protected processPostApiEventEndpointIdGetByFilter(response: Response): Promise<SearchResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchResponse>(null as any);
    }

    /**
     * Your GET endpoint
     * @return OK
     */
    getMetadataEndpoint(endpointId: string): Promise<Metadata> {
        let url_ = this.baseUrl + "/api/metadata/{endpointId}";
        if (endpointId === undefined || endpointId === null)
            throw new Error("The parameter 'endpointId' must be defined.");
        url_ = url_.replace("{endpointId}", encodeURIComponent("" + endpointId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMetadataEndpoint(_response);
        });
    }

    protected processGetMetadataEndpoint(response: Response): Promise<Metadata> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Metadata.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Metadata>(null as any);
    }

    /**
     * Your POST endpoint
     * @param body (optional) 
     * @return OK
     */
    postMetadataEndpoint(endpointId: string, body?: Metadata | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/metadata/{endpointId}";
        if (endpointId === undefined || endpointId === null)
            throw new Error("The parameter 'endpointId' must be defined.");
        url_ = url_.replace("{endpointId}", encodeURIComponent("" + endpointId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostMetadataEndpoint(_response);
        });
    }

    protected processPostMetadataEndpoint(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Metadata short
     * @param body (optional) 
     * @return OK
     */
    postApiMetadatashort(body?: string[] | undefined): Promise<MetadataShort[]> {
        let url_ = this.baseUrl + "/api/metadatashort";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostApiMetadatashort(_response);
        });
    }

    protected processPostApiMetadatashort(response: Response): Promise<MetadataShort[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MetadataShort.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MetadataShort[]>(null as any);
    }

    /**
     * Heartbeat storagehook
     * @return OK
     */
    postApiStoragehookHeartbeatEndpointId(endpointId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/storagehook/heartbeat/{endpointId}";
        if (endpointId === undefined || endpointId === null)
            throw new Error("The parameter 'endpointId' must be defined.");
        url_ = url_.replace("{endpointId}", encodeURIComponent("" + endpointId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostApiStoragehookHeartbeatEndpointId(_response);
        });
    }

    protected processPostApiStoragehookHeartbeatEndpointId(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class OldEvent implements IOldEvent {
    updatedAt?: moment.Moment;
    eventId?: string;
    sessionId?: string;
    correlationId?: string;
    resolutionStatus?: string;
    endpointRole?: string;
    endpointId?: string;
    retryCount?: string;
    messageType?: string;
    deadLetterReason?: string;
    originatingMessageId?: string;
    retryLimit?: string;
    originatingMessage?: Message;
    reason?: string;

    constructor(data?: IOldEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            this.eventId = _data["eventId"];
            this.sessionId = _data["sessionId"];
            this.correlationId = _data["correlationId"];
            this.resolutionStatus = _data["resolutionStatus"];
            this.endpointRole = _data["endpointRole"];
            this.endpointId = _data["endpointId"];
            this.retryCount = _data["retryCount"];
            this.messageType = _data["messageType"];
            this.deadLetterReason = _data["deadLetterReason"];
            this.originatingMessageId = _data["originatingMessageId"];
            this.retryLimit = _data["retryLimit"];
            this.originatingMessage = _data["originatingMessage"] ? Message.fromJS(_data["originatingMessage"]) : <any>undefined;
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): OldEvent {
        data = typeof data === 'object' ? data : {};
        let result = new OldEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["eventId"] = this.eventId;
        data["sessionId"] = this.sessionId;
        data["correlationId"] = this.correlationId;
        data["resolutionStatus"] = this.resolutionStatus;
        data["endpointRole"] = this.endpointRole;
        data["endpointId"] = this.endpointId;
        data["retryCount"] = this.retryCount;
        data["messageType"] = this.messageType;
        data["deadLetterReason"] = this.deadLetterReason;
        data["originatingMessageId"] = this.originatingMessageId;
        data["retryLimit"] = this.retryLimit;
        data["originatingMessage"] = this.originatingMessage ? this.originatingMessage.toJSON() : <any>undefined;
        data["reason"] = this.reason;
        return data;
    }

    clone(): OldEvent {
        const json = this.toJSON();
        let result = new OldEvent();
        result.init(json);
        return result;
    }
}

export interface IOldEvent {
    updatedAt?: moment.Moment;
    eventId?: string;
    sessionId?: string;
    correlationId?: string;
    resolutionStatus?: string;
    endpointRole?: string;
    endpointId?: string;
    retryCount?: string;
    messageType?: string;
    deadLetterReason?: string;
    originatingMessageId?: string;
    retryLimit?: string;
    originatingMessage?: Message;
    reason?: string;
}

export class EventDetails implements IEventDetails {
    failedMessage?: Message;
    originatingMessage?: Message;
    eventHistory?: Message[];
    logEntries?: EventLogEntry[];

    constructor(data?: IEventDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.failedMessage = _data["failedMessage"] ? Message.fromJS(_data["failedMessage"]) : <any>undefined;
            this.originatingMessage = _data["originatingMessage"] ? Message.fromJS(_data["originatingMessage"]) : <any>undefined;
            if (Array.isArray(_data["eventHistory"])) {
                this.eventHistory = [] as any;
                for (let item of _data["eventHistory"])
                    this.eventHistory!.push(Message.fromJS(item));
            }
            if (Array.isArray(_data["logEntries"])) {
                this.logEntries = [] as any;
                for (let item of _data["logEntries"])
                    this.logEntries!.push(EventLogEntry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EventDetails {
        data = typeof data === 'object' ? data : {};
        let result = new EventDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["failedMessage"] = this.failedMessage ? this.failedMessage.toJSON() : <any>undefined;
        data["originatingMessage"] = this.originatingMessage ? this.originatingMessage.toJSON() : <any>undefined;
        if (Array.isArray(this.eventHistory)) {
            data["eventHistory"] = [];
            for (let item of this.eventHistory)
                data["eventHistory"].push(item.toJSON());
        }
        if (Array.isArray(this.logEntries)) {
            data["logEntries"] = [];
            for (let item of this.logEntries)
                data["logEntries"].push(item.toJSON());
        }
        return data;
    }

    clone(): EventDetails {
        const json = this.toJSON();
        let result = new EventDetails();
        result.init(json);
        return result;
    }
}

export interface IEventDetails {
    failedMessage?: Message;
    originatingMessage?: Message;
    eventHistory?: Message[];
    logEntries?: EventLogEntry[];
}

export class EventLogEntry implements IEventLogEntry {
    text?: string;
    eventType?: string;
    to?: string;
    from?: string;
    eventId?: string;
    correlationId?: string;
    payload?: string;
    sessionId?: string;
    timeStamp?: moment.Moment;
    messageType?: string;
    isDeferred?: boolean;
    messageId?: string;
    severityLevel?: EventLogEntrySeverityLevel;

    constructor(data?: IEventLogEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.eventType = _data["eventType"];
            this.to = _data["to"];
            this.from = _data["from"];
            this.eventId = _data["eventId"];
            this.correlationId = _data["correlationId"];
            this.payload = _data["payload"];
            this.sessionId = _data["sessionId"];
            this.timeStamp = _data["timeStamp"] ? moment(_data["timeStamp"].toString()) : <any>undefined;
            this.messageType = _data["messageType"];
            this.isDeferred = _data["isDeferred"];
            this.messageId = _data["messageId"];
            this.severityLevel = _data["severityLevel"];
        }
    }

    static fromJS(data: any): EventLogEntry {
        data = typeof data === 'object' ? data : {};
        let result = new EventLogEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["eventType"] = this.eventType;
        data["to"] = this.to;
        data["from"] = this.from;
        data["eventId"] = this.eventId;
        data["correlationId"] = this.correlationId;
        data["payload"] = this.payload;
        data["sessionId"] = this.sessionId;
        data["timeStamp"] = this.timeStamp ? this.timeStamp.toISOString() : <any>undefined;
        data["messageType"] = this.messageType;
        data["isDeferred"] = this.isDeferred;
        data["messageId"] = this.messageId;
        data["severityLevel"] = this.severityLevel;
        return data;
    }

    clone(): EventLogEntry {
        const json = this.toJSON();
        let result = new EventLogEntry();
        result.init(json);
        return result;
    }
}

export interface IEventLogEntry {
    text?: string;
    eventType?: string;
    to?: string;
    from?: string;
    eventId?: string;
    correlationId?: string;
    payload?: string;
    sessionId?: string;
    timeStamp?: moment.Moment;
    messageType?: string;
    isDeferred?: boolean;
    messageId?: string;
    severityLevel?: EventLogEntrySeverityLevel;
}

export class Message implements IMessage {
    eventId?: string;
    messageId?: string;
    originatingMessageId?: string;
    parentMessageId?: string;
    from?: string;
    to?: string;
    sessionId?: string;
    correlationId?: string;
    enqueuedTimeUtc?: moment.Moment;
    messageType?: MessageType;
    endpointRole?: MessageEndpointRole;
    endpointId?: string;
    eventTypeId?: string;
    eventContent?: string;
    errorContent?: MessageErrorContent;
    originatingFrom?: string;

    constructor(data?: IMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventId = _data["eventId"];
            this.messageId = _data["messageId"];
            this.originatingMessageId = _data["originatingMessageId"];
            this.parentMessageId = _data["parentMessageId"];
            this.from = _data["from"];
            this.to = _data["to"];
            this.sessionId = _data["sessionId"];
            this.correlationId = _data["correlationId"];
            this.enqueuedTimeUtc = _data["enqueuedTimeUtc"] ? moment(_data["enqueuedTimeUtc"].toString()) : <any>undefined;
            this.messageType = _data["messageType"];
            this.endpointRole = _data["endpointRole"];
            this.endpointId = _data["endpointId"];
            this.eventTypeId = _data["eventTypeId"];
            this.eventContent = _data["eventContent"];
            this.errorContent = _data["errorContent"] ? MessageErrorContent.fromJS(_data["errorContent"]) : <any>undefined;
            this.originatingFrom = _data["originatingFrom"];
        }
    }

    static fromJS(data: any): Message {
        data = typeof data === 'object' ? data : {};
        let result = new Message();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId;
        data["messageId"] = this.messageId;
        data["originatingMessageId"] = this.originatingMessageId;
        data["parentMessageId"] = this.parentMessageId;
        data["from"] = this.from;
        data["to"] = this.to;
        data["sessionId"] = this.sessionId;
        data["correlationId"] = this.correlationId;
        data["enqueuedTimeUtc"] = this.enqueuedTimeUtc ? this.enqueuedTimeUtc.toISOString() : <any>undefined;
        data["messageType"] = this.messageType;
        data["endpointRole"] = this.endpointRole;
        data["endpointId"] = this.endpointId;
        data["eventTypeId"] = this.eventTypeId;
        data["eventContent"] = this.eventContent;
        data["errorContent"] = this.errorContent ? this.errorContent.toJSON() : <any>undefined;
        data["originatingFrom"] = this.originatingFrom;
        return data;
    }

    clone(): Message {
        const json = this.toJSON();
        let result = new Message();
        result.init(json);
        return result;
    }
}

export interface IMessage {
    eventId?: string;
    messageId?: string;
    originatingMessageId?: string;
    parentMessageId?: string;
    from?: string;
    to?: string;
    sessionId?: string;
    correlationId?: string;
    enqueuedTimeUtc?: moment.Moment;
    messageType?: MessageType;
    endpointRole?: MessageEndpointRole;
    endpointId?: string;
    eventTypeId?: string;
    eventContent?: string;
    errorContent?: MessageErrorContent;
    originatingFrom?: string;
}

export class EndpointStatus implements IEndpointStatus {
    endpointId?: string;
    eventTime?: moment.Moment;
    failedEvents?: string[];
    pendingEvents?: string[];
    deferredEvents?: string[];
    enrichedUnresolvedEvents?: Event[];
    continuationToken?: string;
    unsupportedEvents?: string[];
    deadletteredEvents?: string[];

    constructor(data?: IEndpointStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.endpointId = _data["endpointId"];
            this.eventTime = _data["eventTime"] ? moment(_data["eventTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["failedEvents"])) {
                this.failedEvents = [] as any;
                for (let item of _data["failedEvents"])
                    this.failedEvents!.push(item);
            }
            if (Array.isArray(_data["pendingEvents"])) {
                this.pendingEvents = [] as any;
                for (let item of _data["pendingEvents"])
                    this.pendingEvents!.push(item);
            }
            if (Array.isArray(_data["deferredEvents"])) {
                this.deferredEvents = [] as any;
                for (let item of _data["deferredEvents"])
                    this.deferredEvents!.push(item);
            }
            if (Array.isArray(_data["enrichedUnresolvedEvents"])) {
                this.enrichedUnresolvedEvents = [] as any;
                for (let item of _data["enrichedUnresolvedEvents"])
                    this.enrichedUnresolvedEvents!.push(Event.fromJS(item));
            }
            this.continuationToken = _data["continuationToken"];
            if (Array.isArray(_data["unsupportedEvents"])) {
                this.unsupportedEvents = [] as any;
                for (let item of _data["unsupportedEvents"])
                    this.unsupportedEvents!.push(item);
            }
            if (Array.isArray(_data["deadletteredEvents"])) {
                this.deadletteredEvents = [] as any;
                for (let item of _data["deadletteredEvents"])
                    this.deadletteredEvents!.push(item);
            }
        }
    }

    static fromJS(data: any): EndpointStatus {
        data = typeof data === 'object' ? data : {};
        let result = new EndpointStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["endpointId"] = this.endpointId;
        data["eventTime"] = this.eventTime ? this.eventTime.toISOString() : <any>undefined;
        if (Array.isArray(this.failedEvents)) {
            data["failedEvents"] = [];
            for (let item of this.failedEvents)
                data["failedEvents"].push(item);
        }
        if (Array.isArray(this.pendingEvents)) {
            data["pendingEvents"] = [];
            for (let item of this.pendingEvents)
                data["pendingEvents"].push(item);
        }
        if (Array.isArray(this.deferredEvents)) {
            data["deferredEvents"] = [];
            for (let item of this.deferredEvents)
                data["deferredEvents"].push(item);
        }
        if (Array.isArray(this.enrichedUnresolvedEvents)) {
            data["enrichedUnresolvedEvents"] = [];
            for (let item of this.enrichedUnresolvedEvents)
                data["enrichedUnresolvedEvents"].push(item.toJSON());
        }
        data["continuationToken"] = this.continuationToken;
        if (Array.isArray(this.unsupportedEvents)) {
            data["unsupportedEvents"] = [];
            for (let item of this.unsupportedEvents)
                data["unsupportedEvents"].push(item);
        }
        if (Array.isArray(this.deadletteredEvents)) {
            data["deadletteredEvents"] = [];
            for (let item of this.deadletteredEvents)
                data["deadletteredEvents"].push(item);
        }
        return data;
    }

    clone(): EndpointStatus {
        const json = this.toJSON();
        let result = new EndpointStatus();
        result.init(json);
        return result;
    }
}

export interface IEndpointStatus {
    endpointId?: string;
    eventTime?: moment.Moment;
    failedEvents?: string[];
    pendingEvents?: string[];
    deferredEvents?: string[];
    enrichedUnresolvedEvents?: Event[];
    continuationToken?: string;
    unsupportedEvents?: string[];
    deadletteredEvents?: string[];
}

export class StorageEventData implements IStorageEventData {

    [key: string]: any;

    constructor(data?: IStorageEventData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): StorageEventData {
        data = typeof data === 'object' ? data : {};
        let result = new StorageEventData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }

    clone(): StorageEventData {
        const json = this.toJSON();
        let result = new StorageEventData();
        result.init(json);
        return result;
    }
}

export interface IStorageEventData {

    [key: string]: any;
}

export class GridEventOfStorageEventData implements IGridEventOfStorageEventData {
    id?: string;
    eventType?: string;
    subject?: string;
    eventTime?: string;
    data?: StorageEventData;
    topic?: string;

    constructor(data?: IGridEventOfStorageEventData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.eventType = _data["eventType"];
            this.subject = _data["subject"];
            this.eventTime = _data["eventTime"];
            this.data = _data["data"] ? StorageEventData.fromJS(_data["data"]) : <any>undefined;
            this.topic = _data["topic"];
        }
    }

    static fromJS(data: any): GridEventOfStorageEventData {
        data = typeof data === 'object' ? data : {};
        let result = new GridEventOfStorageEventData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["eventType"] = this.eventType;
        data["subject"] = this.subject;
        data["eventTime"] = this.eventTime;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["topic"] = this.topic;
        return data;
    }

    clone(): GridEventOfStorageEventData {
        const json = this.toJSON();
        let result = new GridEventOfStorageEventData();
        result.init(json);
        return result;
    }
}

export interface IGridEventOfStorageEventData {
    id?: string;
    eventType?: string;
    subject?: string;
    eventTime?: string;
    data?: StorageEventData;
    topic?: string;
}

export class BlobEvent implements IBlobEvent {
    api?: string;
    clientRequestId?: string;
    requestId?: string;
    eTag?: string;
    contentType?: string;
    contentLength?: number;
    blobType?: string;
    url?: string;
    sequencer?: string;
    storageDiagnostics?: StorageDiagnostics;

    constructor(data?: IBlobEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.api = _data["api"];
            this.clientRequestId = _data["clientRequestId"];
            this.requestId = _data["requestId"];
            this.eTag = _data["eTag"];
            this.contentType = _data["contentType"];
            this.contentLength = _data["contentLength"];
            this.blobType = _data["blobType"];
            this.url = _data["url"];
            this.sequencer = _data["sequencer"];
            this.storageDiagnostics = _data["storageDiagnostics"] ? StorageDiagnostics.fromJS(_data["storageDiagnostics"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BlobEvent {
        data = typeof data === 'object' ? data : {};
        let result = new BlobEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["api"] = this.api;
        data["clientRequestId"] = this.clientRequestId;
        data["requestId"] = this.requestId;
        data["eTag"] = this.eTag;
        data["contentType"] = this.contentType;
        data["contentLength"] = this.contentLength;
        data["blobType"] = this.blobType;
        data["url"] = this.url;
        data["sequencer"] = this.sequencer;
        data["storageDiagnostics"] = this.storageDiagnostics ? this.storageDiagnostics.toJSON() : <any>undefined;
        return data;
    }

    clone(): BlobEvent {
        const json = this.toJSON();
        let result = new BlobEvent();
        result.init(json);
        return result;
    }
}

export interface IBlobEvent {
    api?: string;
    clientRequestId?: string;
    requestId?: string;
    eTag?: string;
    contentType?: string;
    contentLength?: number;
    blobType?: string;
    url?: string;
    sequencer?: string;
    storageDiagnostics?: StorageDiagnostics;
}

export class CloudEvent implements ICloudEvent {
    specversion?: string;
    type?: string;
    source?: string;
    subject?: string;
    id?: string;
    time?: string;
    data?: CloudEvent;

    constructor(data?: ICloudEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.specversion = _data["specversion"];
            this.type = _data["type"];
            this.source = _data["source"];
            this.subject = _data["subject"];
            this.id = _data["id"];
            this.time = _data["time"];
            this.data = _data["data"] ? CloudEvent.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CloudEvent {
        data = typeof data === 'object' ? data : {};
        let result = new CloudEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["specversion"] = this.specversion;
        data["type"] = this.type;
        data["source"] = this.source;
        data["subject"] = this.subject;
        data["id"] = this.id;
        data["time"] = this.time;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): CloudEvent {
        const json = this.toJSON();
        let result = new CloudEvent();
        result.init(json);
        return result;
    }
}

export interface ICloudEvent {
    specversion?: string;
    type?: string;
    source?: string;
    subject?: string;
    id?: string;
    time?: string;
    data?: CloudEvent;
}

export class EndpointStateEvent implements IEndpointStateEvent {
    endpointId?: string;
    hasErrors?: boolean;
    eventTime?: moment.Moment;
    endpointState?: EndpointStatus;
    originatingEvent?: GridEventOfStorageEventData;

    constructor(data?: IEndpointStateEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.endpointId = _data["endpointId"];
            this.hasErrors = _data["hasErrors"];
            this.eventTime = _data["eventTime"] ? moment(_data["eventTime"].toString()) : <any>undefined;
            this.endpointState = _data["endpointState"] ? EndpointStatus.fromJS(_data["endpointState"]) : <any>undefined;
            this.originatingEvent = _data["originatingEvent"] ? GridEventOfStorageEventData.fromJS(_data["originatingEvent"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EndpointStateEvent {
        data = typeof data === 'object' ? data : {};
        let result = new EndpointStateEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["endpointId"] = this.endpointId;
        data["hasErrors"] = this.hasErrors;
        data["eventTime"] = this.eventTime ? this.eventTime.toISOString() : <any>undefined;
        data["endpointState"] = this.endpointState ? this.endpointState.toJSON() : <any>undefined;
        data["originatingEvent"] = this.originatingEvent ? this.originatingEvent.toJSON() : <any>undefined;
        return data;
    }

    clone(): EndpointStateEvent {
        const json = this.toJSON();
        let result = new EndpointStateEvent();
        result.init(json);
        return result;
    }
}

export interface IEndpointStateEvent {
    endpointId?: string;
    hasErrors?: boolean;
    eventTime?: moment.Moment;
    endpointState?: EndpointStatus;
    originatingEvent?: GridEventOfStorageEventData;
}

export class MessageErrorContent implements IMessageErrorContent {
    errorText?: string;
    errorType?: string;
    exceptionStackTrace?: string;
    exceptionSource?: string;

    constructor(data?: IMessageErrorContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorText = _data["errorText"];
            this.errorType = _data["errorType"];
            this.exceptionStackTrace = _data["exceptionStackTrace"];
            this.exceptionSource = _data["exceptionSource"];
        }
    }

    static fromJS(data: any): MessageErrorContent {
        data = typeof data === 'object' ? data : {};
        let result = new MessageErrorContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorText"] = this.errorText;
        data["errorType"] = this.errorType;
        data["exceptionStackTrace"] = this.exceptionStackTrace;
        data["exceptionSource"] = this.exceptionSource;
        return data;
    }

    clone(): MessageErrorContent {
        const json = this.toJSON();
        let result = new MessageErrorContent();
        result.init(json);
        return result;
    }
}

export interface IMessageErrorContent {
    errorText?: string;
    errorType?: string;
    exceptionStackTrace?: string;
    exceptionSource?: string;
}

export class EventType implements IEventType {
    id?: string;
    name?: string;
    description?: string;
    namespace?: string;
    properties?: EventTypeProperty[];

    constructor(data?: IEventType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.namespace = _data["namespace"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(EventTypeProperty.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EventType {
        data = typeof data === 'object' ? data : {};
        let result = new EventType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["namespace"] = this.namespace;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        return data;
    }

    clone(): EventType {
        const json = this.toJSON();
        let result = new EventType();
        result.init(json);
        return result;
    }
}

export interface IEventType {
    id?: string;
    name?: string;
    description?: string;
    namespace?: string;
    properties?: EventTypeProperty[];
}

export class EventTypeProperty implements IEventTypeProperty {
    name?: string;
    typeName?: string;
    typeFullName?: string;
    description?: string;
    isRequired?: boolean;

    constructor(data?: IEventTypeProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.typeName = _data["typeName"];
            this.typeFullName = _data["typeFullName"];
            this.description = _data["description"];
            this.isRequired = _data["isRequired"];
        }
    }

    static fromJS(data: any): EventTypeProperty {
        data = typeof data === 'object' ? data : {};
        let result = new EventTypeProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["typeName"] = this.typeName;
        data["typeFullName"] = this.typeFullName;
        data["description"] = this.description;
        data["isRequired"] = this.isRequired;
        return data;
    }

    clone(): EventTypeProperty {
        const json = this.toJSON();
        let result = new EventTypeProperty();
        result.init(json);
        return result;
    }
}

export interface IEventTypeProperty {
    name?: string;
    typeName?: string;
    typeFullName?: string;
    description?: string;
    isRequired?: boolean;
}

export class EventTypeDetails implements IEventTypeDetails {
    eventType?: EventType;
    codeRepoLink?: string;
    producers?: string[];
    consumers?: string[];

    constructor(data?: IEventTypeDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventType = _data["eventType"] ? EventType.fromJS(_data["eventType"]) : <any>undefined;
            this.codeRepoLink = _data["codeRepoLink"];
            if (Array.isArray(_data["producers"])) {
                this.producers = [] as any;
                for (let item of _data["producers"])
                    this.producers!.push(item);
            }
            if (Array.isArray(_data["consumers"])) {
                this.consumers = [] as any;
                for (let item of _data["consumers"])
                    this.consumers!.push(item);
            }
        }
    }

    static fromJS(data: any): EventTypeDetails {
        data = typeof data === 'object' ? data : {};
        let result = new EventTypeDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventType"] = this.eventType ? this.eventType.toJSON() : <any>undefined;
        data["codeRepoLink"] = this.codeRepoLink;
        if (Array.isArray(this.producers)) {
            data["producers"] = [];
            for (let item of this.producers)
                data["producers"].push(item);
        }
        if (Array.isArray(this.consumers)) {
            data["consumers"] = [];
            for (let item of this.consumers)
                data["consumers"].push(item);
        }
        return data;
    }

    clone(): EventTypeDetails {
        const json = this.toJSON();
        let result = new EventTypeDetails();
        result.init(json);
        return result;
    }
}

export interface IEventTypeDetails {
    eventType?: EventType;
    codeRepoLink?: string;
    producers?: string[];
    consumers?: string[];
}

export class EventTypeGrouping implements IEventTypeGrouping {
    namespace?: string;
    events?: EventType[];

    constructor(data?: IEventTypeGrouping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.namespace = _data["namespace"];
            if (Array.isArray(_data["events"])) {
                this.events = [] as any;
                for (let item of _data["events"])
                    this.events!.push(EventType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EventTypeGrouping {
        data = typeof data === 'object' ? data : {};
        let result = new EventTypeGrouping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["namespace"] = this.namespace;
        if (Array.isArray(this.events)) {
            data["events"] = [];
            for (let item of this.events)
                data["events"].push(item.toJSON());
        }
        return data;
    }

    clone(): EventTypeGrouping {
        const json = this.toJSON();
        let result = new EventTypeGrouping();
        result.init(json);
        return result;
    }
}

export interface IEventTypeGrouping {
    namespace?: string;
    events?: EventType[];
}

export class ApplicationStatus implements IApplicationStatus {
    env?: string;
    platformVersion?: string;

    constructor(data?: IApplicationStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.env = _data["env"];
            this.platformVersion = _data["platformVersion"];
        }
    }

    static fromJS(data: any): ApplicationStatus {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["env"] = this.env;
        data["platformVersion"] = this.platformVersion;
        return data;
    }

    clone(): ApplicationStatus {
        const json = this.toJSON();
        let result = new ApplicationStatus();
        result.init(json);
        return result;
    }
}

export interface IApplicationStatus {
    env?: string;
    platformVersion?: string;
}

export class EndpointStatusCount implements IEndpointStatusCount {
    endpointId?: string;
    subscriptionStatus?: string;
    eventTime?: moment.Moment;
    failedCount?: number;
    deferredCount?: number;
    pendingCount?: number;
    unsupportedCount?: number;
    deadletterCount?: number;

    constructor(data?: IEndpointStatusCount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.endpointId = _data["endpointId"];
            this.subscriptionStatus = _data["subscriptionStatus"];
            this.eventTime = _data["eventTime"] ? moment(_data["eventTime"].toString()) : <any>undefined;
            this.failedCount = _data["failedCount"];
            this.deferredCount = _data["deferredCount"];
            this.pendingCount = _data["pendingCount"];
            this.unsupportedCount = _data["unsupportedCount"];
            this.deadletterCount = _data["deadletterCount"];
        }
    }

    static fromJS(data: any): EndpointStatusCount {
        data = typeof data === 'object' ? data : {};
        let result = new EndpointStatusCount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["endpointId"] = this.endpointId;
        data["subscriptionStatus"] = this.subscriptionStatus;
        data["eventTime"] = this.eventTime ? this.eventTime.toISOString() : <any>undefined;
        data["failedCount"] = this.failedCount;
        data["deferredCount"] = this.deferredCount;
        data["pendingCount"] = this.pendingCount;
        data["unsupportedCount"] = this.unsupportedCount;
        data["deadletterCount"] = this.deadletterCount;
        return data;
    }

    clone(): EndpointStatusCount {
        const json = this.toJSON();
        let result = new EndpointStatusCount();
        result.init(json);
        return result;
    }
}

export interface IEndpointStatusCount {
    endpointId?: string;
    subscriptionStatus?: string;
    eventTime?: moment.Moment;
    failedCount?: number;
    deferredCount?: number;
    pendingCount?: number;
    unsupportedCount?: number;
    deadletterCount?: number;
}

export class SessionStatus implements ISessionStatus {
    sessionId?: string;
    pendingEvents?: string[];
    deferredEvents?: string[];

    constructor(data?: ISessionStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sessionId = _data["sessionId"];
            if (Array.isArray(_data["pendingEvents"])) {
                this.pendingEvents = [] as any;
                for (let item of _data["pendingEvents"])
                    this.pendingEvents!.push(item);
            }
            if (Array.isArray(_data["deferredEvents"])) {
                this.deferredEvents = [] as any;
                for (let item of _data["deferredEvents"])
                    this.deferredEvents!.push(item);
            }
        }
    }

    static fromJS(data: any): SessionStatus {
        data = typeof data === 'object' ? data : {};
        let result = new SessionStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionId"] = this.sessionId;
        if (Array.isArray(this.pendingEvents)) {
            data["pendingEvents"] = [];
            for (let item of this.pendingEvents)
                data["pendingEvents"].push(item);
        }
        if (Array.isArray(this.deferredEvents)) {
            data["deferredEvents"] = [];
            for (let item of this.deferredEvents)
                data["deferredEvents"].push(item);
        }
        return data;
    }

    clone(): SessionStatus {
        const json = this.toJSON();
        let result = new SessionStatus();
        result.init(json);
        return result;
    }
}

export interface ISessionStatus {
    sessionId?: string;
    pendingEvents?: string[];
    deferredEvents?: string[];
}

export class ContinuationToken implements IContinuationToken {
    token?: string;

    constructor(data?: IContinuationToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ContinuationToken {
        data = typeof data === 'object' ? data : {};
        let result = new ContinuationToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }

    clone(): ContinuationToken {
        const json = this.toJSON();
        let result = new ContinuationToken();
        result.init(json);
        return result;
    }
}

export interface IContinuationToken {
    token?: string;
}

export class MessageAudit implements IMessageAudit {
    auditorName?: string;
    auditTimestamp?: moment.Moment;
    auditType?: MessageAuditAuditType;

    constructor(data?: IMessageAudit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.auditorName = _data["auditorName"];
            this.auditTimestamp = _data["auditTimestamp"] ? moment(_data["auditTimestamp"].toString()) : <any>undefined;
            this.auditType = _data["auditType"];
        }
    }

    static fromJS(data: any): MessageAudit {
        data = typeof data === 'object' ? data : {};
        let result = new MessageAudit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["auditorName"] = this.auditorName;
        data["auditTimestamp"] = this.auditTimestamp ? this.auditTimestamp.toISOString() : <any>undefined;
        data["auditType"] = this.auditType;
        return data;
    }

    clone(): MessageAudit {
        const json = this.toJSON();
        let result = new MessageAudit();
        result.init(json);
        return result;
    }
}

export interface IMessageAudit {
    auditorName?: string;
    auditTimestamp?: moment.Moment;
    auditType?: MessageAuditAuditType;
}

export class BlockedEvent implements IBlockedEvent {
    originatingId?: string;
    eventId?: string;
    status?: string;

    constructor(data?: IBlockedEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.originatingId = _data["originatingId"];
            this.eventId = _data["eventId"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): BlockedEvent {
        data = typeof data === 'object' ? data : {};
        let result = new BlockedEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["originatingId"] = this.originatingId;
        data["eventId"] = this.eventId;
        data["status"] = this.status;
        return data;
    }

    clone(): BlockedEvent {
        const json = this.toJSON();
        let result = new BlockedEvent();
        result.init(json);
        return result;
    }
}

export interface IBlockedEvent {
    originatingId?: string;
    eventId?: string;
    status?: string;
}

export class PendingEvent implements IPendingEvent {
    originatingId?: string;
    eventId?: string;
    status?: string;

    constructor(data?: IPendingEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.originatingId = _data["originatingId"];
            this.eventId = _data["eventId"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): PendingEvent {
        data = typeof data === 'object' ? data : {};
        let result = new PendingEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["originatingId"] = this.originatingId;
        data["eventId"] = this.eventId;
        data["status"] = this.status;
        return data;
    }

    clone(): PendingEvent {
        const json = this.toJSON();
        let result = new PendingEvent();
        result.init(json);
        return result;
    }
}

export interface IPendingEvent {
    originatingId?: string;
    eventId?: string;
    status?: string;
}

export class EndpointSubscription implements IEndpointSubscription {
    type?: string;
    notificationSeverity?: string;
    mail?: string;
    authorId?: string;
    url?: string;
    eventTypes?: string[];
    payload?: string;
    frequency?: number;
    id?: string;

    constructor(data?: IEndpointSubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.notificationSeverity = _data["notificationSeverity"];
            this.mail = _data["mail"];
            this.authorId = _data["authorId"];
            this.url = _data["url"];
            if (Array.isArray(_data["eventTypes"])) {
                this.eventTypes = [] as any;
                for (let item of _data["eventTypes"])
                    this.eventTypes!.push(item);
            }
            this.payload = _data["payload"];
            this.frequency = _data["frequency"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EndpointSubscription {
        data = typeof data === 'object' ? data : {};
        let result = new EndpointSubscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["notificationSeverity"] = this.notificationSeverity;
        data["mail"] = this.mail;
        data["authorId"] = this.authorId;
        data["url"] = this.url;
        if (Array.isArray(this.eventTypes)) {
            data["eventTypes"] = [];
            for (let item of this.eventTypes)
                data["eventTypes"].push(item);
        }
        data["payload"] = this.payload;
        data["frequency"] = this.frequency;
        data["id"] = this.id;
        return data;
    }

    clone(): EndpointSubscription {
        const json = this.toJSON();
        let result = new EndpointSubscription();
        result.init(json);
        return result;
    }
}

export interface IEndpointSubscription {
    type?: string;
    notificationSeverity?: string;
    mail?: string;
    authorId?: string;
    url?: string;
    eventTypes?: string[];
    payload?: string;
    frequency?: number;
    id?: string;
}

export class Subscription implements ISubscription {
    id?: string;
    type?: string;
    mail?: string;
    severity?: string;
    authorId?: string;
    url?: string;

    constructor(data?: ISubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.mail = _data["mail"];
            this.severity = _data["severity"];
            this.authorId = _data["authorId"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): Subscription {
        data = typeof data === 'object' ? data : {};
        let result = new Subscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["mail"] = this.mail;
        data["severity"] = this.severity;
        data["authorId"] = this.authorId;
        data["url"] = this.url;
        return data;
    }

    clone(): Subscription {
        const json = this.toJSON();
        let result = new Subscription();
        result.init(json);
        return result;
    }
}

export interface ISubscription {
    id?: string;
    type?: string;
    mail?: string;
    severity?: string;
    authorId?: string;
    url?: string;
}

export class SubscriptionAuthor implements ISubscriptionAuthor {
    id?: string;
    author?: string;

    constructor(data?: ISubscriptionAuthor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.author = _data["author"];
        }
    }

    static fromJS(data: any): SubscriptionAuthor {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionAuthor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["author"] = this.author;
        return data;
    }

    clone(): SubscriptionAuthor {
        const json = this.toJSON();
        let result = new SubscriptionAuthor();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionAuthor {
    id?: string;
    author?: string;
}

export class ResubmitWithChanges implements IResubmitWithChanges {
    eventTypeId?: string;
    eventContent?: string;

    constructor(data?: IResubmitWithChanges) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventTypeId = _data["eventTypeId"];
            this.eventContent = _data["eventContent"];
        }
    }

    static fromJS(data: any): ResubmitWithChanges {
        data = typeof data === 'object' ? data : {};
        let result = new ResubmitWithChanges();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventTypeId"] = this.eventTypeId;
        data["eventContent"] = this.eventContent;
        return data;
    }

    clone(): ResubmitWithChanges {
        const json = this.toJSON();
        let result = new ResubmitWithChanges();
        result.init(json);
        return result;
    }
}

export interface IResubmitWithChanges {
    eventTypeId?: string;
    eventContent?: string;
}

export class Event implements IEvent {
    updatedAt?: moment.Moment;
    enqueuedTimeUtc?: moment.Moment;
    eventId?: string;
    sessionId?: string;
    correlationId?: string;
    resolutionStatus?: string;
    endpointRole?: string;
    endpointId?: string;
    retryCount?: number | undefined;
    retryLimit?: number | undefined;
    messageType?: string;
    deadLetterReason?: string;
    deadLetterErrorDescription?: string;
    lastMessageId?: string;
    originatingMessageId?: string;
    parentMessageId?: string;
    reason?: string;
    originatingFrom?: string;
    eventTypeId?: string;
    to?: string;
    from?: string;
    messageContent?: MessageContent;

    constructor(data?: IEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            this.enqueuedTimeUtc = _data["enqueuedTimeUtc"] ? moment(_data["enqueuedTimeUtc"].toString()) : <any>undefined;
            this.eventId = _data["eventId"];
            this.sessionId = _data["sessionId"];
            this.correlationId = _data["correlationId"];
            this.resolutionStatus = _data["resolutionStatus"];
            this.endpointRole = _data["endpointRole"];
            this.endpointId = _data["endpointId"];
            this.retryCount = _data["retryCount"];
            this.retryLimit = _data["retryLimit"];
            this.messageType = _data["messageType"];
            this.deadLetterReason = _data["deadLetterReason"];
            this.deadLetterErrorDescription = _data["deadLetterErrorDescription"];
            this.lastMessageId = _data["lastMessageId"];
            this.originatingMessageId = _data["originatingMessageId"];
            this.parentMessageId = _data["parentMessageId"];
            this.reason = _data["reason"];
            this.originatingFrom = _data["originatingFrom"];
            this.eventTypeId = _data["eventTypeId"];
            this.to = _data["to"];
            this.from = _data["from"];
            this.messageContent = _data["messageContent"] ? MessageContent.fromJS(_data["messageContent"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Event {
        data = typeof data === 'object' ? data : {};
        let result = new Event();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["enqueuedTimeUtc"] = this.enqueuedTimeUtc ? this.enqueuedTimeUtc.toISOString() : <any>undefined;
        data["eventId"] = this.eventId;
        data["sessionId"] = this.sessionId;
        data["correlationId"] = this.correlationId;
        data["resolutionStatus"] = this.resolutionStatus;
        data["endpointRole"] = this.endpointRole;
        data["endpointId"] = this.endpointId;
        data["retryCount"] = this.retryCount;
        data["retryLimit"] = this.retryLimit;
        data["messageType"] = this.messageType;
        data["deadLetterReason"] = this.deadLetterReason;
        data["deadLetterErrorDescription"] = this.deadLetterErrorDescription;
        data["lastMessageId"] = this.lastMessageId;
        data["originatingMessageId"] = this.originatingMessageId;
        data["parentMessageId"] = this.parentMessageId;
        data["reason"] = this.reason;
        data["originatingFrom"] = this.originatingFrom;
        data["eventTypeId"] = this.eventTypeId;
        data["to"] = this.to;
        data["from"] = this.from;
        data["messageContent"] = this.messageContent ? this.messageContent.toJSON() : <any>undefined;
        return data;
    }

    clone(): Event {
        const json = this.toJSON();
        let result = new Event();
        result.init(json);
        return result;
    }
}

export interface IEvent {
    updatedAt?: moment.Moment;
    enqueuedTimeUtc?: moment.Moment;
    eventId?: string;
    sessionId?: string;
    correlationId?: string;
    resolutionStatus?: string;
    endpointRole?: string;
    endpointId?: string;
    retryCount?: number | undefined;
    retryLimit?: number | undefined;
    messageType?: string;
    deadLetterReason?: string;
    deadLetterErrorDescription?: string;
    lastMessageId?: string;
    originatingMessageId?: string;
    parentMessageId?: string;
    reason?: string;
    originatingFrom?: string;
    eventTypeId?: string;
    to?: string;
    from?: string;
    messageContent?: MessageContent;
}

export class EventFilter implements IEventFilter {
    endpointId?: string;
    updateAtFrom?: moment.Moment | undefined;
    updatedAtTo?: moment.Moment | undefined;
    enqueuedAtFrom?: moment.Moment | undefined;
    enqueuedAtTo!: moment.Moment | undefined;
    eventId?: string | undefined;
    eventTypeId?: string[] | undefined;
    sessionId?: string | undefined;
    to?: string | undefined;
    from?: string | undefined;
    resolutionStatus?: ResolutionStatus[] | undefined;
    payload?: string | undefined;

    constructor(data?: IEventFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.endpointId = _data["endpointId"];
            this.updateAtFrom = _data["updateAtFrom"] ? moment(_data["updateAtFrom"].toString()) : <any>undefined;
            this.updatedAtTo = _data["updatedAtTo"] ? moment(_data["updatedAtTo"].toString()) : <any>undefined;
            this.enqueuedAtFrom = _data["enqueuedAtFrom"] ? moment(_data["enqueuedAtFrom"].toString()) : <any>undefined;
            this.enqueuedAtTo = _data["enqueuedAtTo"] ? moment(_data["enqueuedAtTo"].toString()) : <any>undefined;
            this.eventId = _data["eventId"];
            if (Array.isArray(_data["eventTypeId"])) {
                this.eventTypeId = [] as any;
                for (let item of _data["eventTypeId"])
                    this.eventTypeId!.push(item);
            }
            this.sessionId = _data["sessionId"];
            this.to = _data["to"];
            this.from = _data["from"];
            if (Array.isArray(_data["resolutionStatus"])) {
                this.resolutionStatus = [] as any;
                for (let item of _data["resolutionStatus"])
                    this.resolutionStatus!.push(item);
            }
            this.payload = _data["payload"];
        }
    }

    static fromJS(data: any): EventFilter {
        data = typeof data === 'object' ? data : {};
        let result = new EventFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["endpointId"] = this.endpointId;
        data["updateAtFrom"] = this.updateAtFrom ? this.updateAtFrom.toISOString() : <any>undefined;
        data["updatedAtTo"] = this.updatedAtTo ? this.updatedAtTo.toISOString() : <any>undefined;
        data["enqueuedAtFrom"] = this.enqueuedAtFrom ? this.enqueuedAtFrom.toISOString() : <any>undefined;
        data["enqueuedAtTo"] = this.enqueuedAtTo ? this.enqueuedAtTo.toISOString() : <any>undefined;
        data["eventId"] = this.eventId;
        if (Array.isArray(this.eventTypeId)) {
            data["eventTypeId"] = [];
            for (let item of this.eventTypeId)
                data["eventTypeId"].push(item);
        }
        data["sessionId"] = this.sessionId;
        data["to"] = this.to;
        data["from"] = this.from;
        if (Array.isArray(this.resolutionStatus)) {
            data["resolutionStatus"] = [];
            for (let item of this.resolutionStatus)
                data["resolutionStatus"].push(item);
        }
        data["payload"] = this.payload;
        return data;
    }

    clone(): EventFilter {
        const json = this.toJSON();
        let result = new EventFilter();
        result.init(json);
        return result;
    }
}

export interface IEventFilter {
    endpointId?: string;
    updateAtFrom?: moment.Moment | undefined;
    updatedAtTo?: moment.Moment | undefined;
    enqueuedAtFrom?: moment.Moment | undefined;
    enqueuedAtTo: moment.Moment | undefined;
    eventId?: string | undefined;
    eventTypeId?: string[] | undefined;
    sessionId?: string | undefined;
    to?: string | undefined;
    from?: string | undefined;
    resolutionStatus?: ResolutionStatus[] | undefined;
    payload?: string | undefined;
}

export class SearchResponse implements ISearchResponse {
    events?: Event[];
    continuationToken?: string | undefined;

    constructor(data?: ISearchResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["events"])) {
                this.events = [] as any;
                for (let item of _data["events"])
                    this.events!.push(Event.fromJS(item));
            }
            this.continuationToken = _data["continuationToken"];
        }
    }

    static fromJS(data: any): SearchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SearchResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.events)) {
            data["events"] = [];
            for (let item of this.events)
                data["events"].push(item.toJSON());
        }
        data["continuationToken"] = this.continuationToken;
        return data;
    }

    clone(): SearchResponse {
        const json = this.toJSON();
        let result = new SearchResponse();
        result.init(json);
        return result;
    }
}

export interface ISearchResponse {
    events?: Event[];
    continuationToken?: string | undefined;
}

export class SearchRequest implements ISearchRequest {
    continuationToken?: string;
    eventFilter?: EventFilter;
    maxSearchItemsCount?: number;

    constructor(data?: ISearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.continuationToken = _data["continuationToken"];
            this.eventFilter = _data["eventFilter"] ? EventFilter.fromJS(_data["eventFilter"]) : <any>undefined;
            this.maxSearchItemsCount = _data["maxSearchItemsCount"];
        }
    }

    static fromJS(data: any): SearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["continuationToken"] = this.continuationToken;
        data["eventFilter"] = this.eventFilter ? this.eventFilter.toJSON() : <any>undefined;
        data["maxSearchItemsCount"] = this.maxSearchItemsCount;
        return data;
    }

    clone(): SearchRequest {
        const json = this.toJSON();
        let result = new SearchRequest();
        result.init(json);
        return result;
    }
}

export interface ISearchRequest {
    continuationToken?: string;
    eventFilter?: EventFilter;
    maxSearchItemsCount?: number;
}

export class Metadata implements IMetadata {
    id?: string;
    endpointOwner?: string;
    endpointOwnerTeam?: string;
    endpointOwnerEmail?: string;
    endpointHeartbeatStatus?: string;
    technicalContacts?: TechnicalContact[];
    heartBeats?: Heartbeat[];
    isHeartbeatEnabled?: boolean | undefined;
    subscriptionStatus?: string;

    constructor(data?: IMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.endpointOwner = _data["endpointOwner"];
            this.endpointOwnerTeam = _data["endpointOwnerTeam"];
            this.endpointOwnerEmail = _data["endpointOwnerEmail"];
            this.endpointHeartbeatStatus = _data["endpointHeartbeatStatus"];
            if (Array.isArray(_data["technicalContacts"])) {
                this.technicalContacts = [] as any;
                for (let item of _data["technicalContacts"])
                    this.technicalContacts!.push(TechnicalContact.fromJS(item));
            }
            if (Array.isArray(_data["heartBeats"])) {
                this.heartBeats = [] as any;
                for (let item of _data["heartBeats"])
                    this.heartBeats!.push(Heartbeat.fromJS(item));
            }
            this.isHeartbeatEnabled = _data["isHeartbeatEnabled"];
            this.subscriptionStatus = _data["subscriptionStatus"];
        }
    }

    static fromJS(data: any): Metadata {
        data = typeof data === 'object' ? data : {};
        let result = new Metadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["endpointOwner"] = this.endpointOwner;
        data["endpointOwnerTeam"] = this.endpointOwnerTeam;
        data["endpointOwnerEmail"] = this.endpointOwnerEmail;
        data["endpointHeartbeatStatus"] = this.endpointHeartbeatStatus;
        if (Array.isArray(this.technicalContacts)) {
            data["technicalContacts"] = [];
            for (let item of this.technicalContacts)
                data["technicalContacts"].push(item.toJSON());
        }
        if (Array.isArray(this.heartBeats)) {
            data["heartBeats"] = [];
            for (let item of this.heartBeats)
                data["heartBeats"].push(item.toJSON());
        }
        data["isHeartbeatEnabled"] = this.isHeartbeatEnabled;
        data["subscriptionStatus"] = this.subscriptionStatus;
        return data;
    }

    clone(): Metadata {
        const json = this.toJSON();
        let result = new Metadata();
        result.init(json);
        return result;
    }
}

export interface IMetadata {
    id?: string;
    endpointOwner?: string;
    endpointOwnerTeam?: string;
    endpointOwnerEmail?: string;
    endpointHeartbeatStatus?: string;
    technicalContacts?: TechnicalContact[];
    heartBeats?: Heartbeat[];
    isHeartbeatEnabled?: boolean | undefined;
    subscriptionStatus?: string;
}

export class TechnicalContact implements ITechnicalContact {
    name?: string;
    email?: string;

    constructor(data?: ITechnicalContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): TechnicalContact {
        data = typeof data === 'object' ? data : {};
        let result = new TechnicalContact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        return data;
    }

    clone(): TechnicalContact {
        const json = this.toJSON();
        let result = new TechnicalContact();
        result.init(json);
        return result;
    }
}

export interface ITechnicalContact {
    name?: string;
    email?: string;
}

export class Heartbeat implements IHeartbeat {
    id?: string;
    startTime?: moment.Moment;
    endTime?: moment.Moment;
    receivedTime?: moment.Moment;
    endpointHeartbeatStatus?: string;
    endpointSubscriptionStatus?: string;

    constructor(data?: IHeartbeat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.receivedTime = _data["receivedTime"] ? moment(_data["receivedTime"].toString()) : <any>undefined;
            this.endpointHeartbeatStatus = _data["endpointHeartbeatStatus"];
            this.endpointSubscriptionStatus = _data["endpointSubscriptionStatus"];
        }
    }

    static fromJS(data: any): Heartbeat {
        data = typeof data === 'object' ? data : {};
        let result = new Heartbeat();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["receivedTime"] = this.receivedTime ? this.receivedTime.toISOString() : <any>undefined;
        data["endpointHeartbeatStatus"] = this.endpointHeartbeatStatus;
        data["endpointSubscriptionStatus"] = this.endpointSubscriptionStatus;
        return data;
    }

    clone(): Heartbeat {
        const json = this.toJSON();
        let result = new Heartbeat();
        result.init(json);
        return result;
    }
}

export interface IHeartbeat {
    id?: string;
    startTime?: moment.Moment;
    endTime?: moment.Moment;
    receivedTime?: moment.Moment;
    endpointHeartbeatStatus?: string;
    endpointSubscriptionStatus?: string;
}

export class MetadataShort implements IMetadataShort {
    endpointId?: string;
    heartbeatStatus?: string;
    isHeartbeatEnabled?: boolean | undefined;
    subscriptionStatus?: string;

    constructor(data?: IMetadataShort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.endpointId = _data["endpointId"];
            this.heartbeatStatus = _data["heartbeatStatus"];
            this.isHeartbeatEnabled = _data["isHeartbeatEnabled"];
            this.subscriptionStatus = _data["subscriptionStatus"];
        }
    }

    static fromJS(data: any): MetadataShort {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataShort();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["endpointId"] = this.endpointId;
        data["heartbeatStatus"] = this.heartbeatStatus;
        data["isHeartbeatEnabled"] = this.isHeartbeatEnabled;
        data["subscriptionStatus"] = this.subscriptionStatus;
        return data;
    }

    clone(): MetadataShort {
        const json = this.toJSON();
        let result = new MetadataShort();
        result.init(json);
        return result;
    }
}

export interface IMetadataShort {
    endpointId?: string;
    heartbeatStatus?: string;
    isHeartbeatEnabled?: boolean | undefined;
    subscriptionStatus?: string;
}

export enum AegEventType {
    SubscriptionValidation = "SubscriptionValidation",
    Notification = "Notification",
}

export class Anonymous implements IAnonymous {
    produces?: EventTypeGrouping[];
    consumes?: EventTypeGrouping[];
    eventTypeDetails?: EventTypeDetails[];

    constructor(data?: IAnonymous) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["produces"])) {
                this.produces = [] as any;
                for (let item of _data["produces"])
                    this.produces!.push(EventTypeGrouping.fromJS(item));
            }
            if (Array.isArray(_data["consumes"])) {
                this.consumes = [] as any;
                for (let item of _data["consumes"])
                    this.consumes!.push(EventTypeGrouping.fromJS(item));
            }
            if (Array.isArray(_data["eventTypeDetails"])) {
                this.eventTypeDetails = [] as any;
                for (let item of _data["eventTypeDetails"])
                    this.eventTypeDetails!.push(EventTypeDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.produces)) {
            data["produces"] = [];
            for (let item of this.produces)
                data["produces"].push(item.toJSON());
        }
        if (Array.isArray(this.consumes)) {
            data["consumes"] = [];
            for (let item of this.consumes)
                data["consumes"].push(item.toJSON());
        }
        if (Array.isArray(this.eventTypeDetails)) {
            data["eventTypeDetails"] = [];
            for (let item of this.eventTypeDetails)
                data["eventTypeDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous {
        const json = this.toJSON();
        let result = new Anonymous();
        result.init(json);
        return result;
    }
}

export interface IAnonymous {
    produces?: EventTypeGrouping[];
    consumes?: EventTypeGrouping[];
    eventTypeDetails?: EventTypeDetails[];
}

export enum EventLogEntrySeverityLevel {
    Verbose = "verbose",
    Information = "information",
    Warning = "warning",
    Critical = "critical",
}

export enum MessageType {
    Unknown = "unknown",
    EventRequest = "eventRequest",
    ErrorResponse = "errorResponse",
    ResolutionResponse = "resolutionResponse",
    SkipResponse = "skipResponse",
    DeferralResponse = "deferralResponse",
    ResubmissionRequest = "resubmissionRequest",
    RetryRequest = "retryRequest",
    SkipRequest = "skipRequest",
    ContinuationRequest = "continuationRequest",
    UnsupportedRequest = "unsupportedRequest",
}

export enum MessageEndpointRole {
    Publisher = "publisher",
    Subscriber = "subscriber",
}

export class StorageDiagnostics implements IStorageDiagnostics {
    batchId?: string;

    constructor(data?: IStorageDiagnostics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.batchId = _data["batchId"];
        }
    }

    static fromJS(data: any): StorageDiagnostics {
        data = typeof data === 'object' ? data : {};
        let result = new StorageDiagnostics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["batchId"] = this.batchId;
        return data;
    }

    clone(): StorageDiagnostics {
        const json = this.toJSON();
        let result = new StorageDiagnostics();
        result.init(json);
        return result;
    }
}

export interface IStorageDiagnostics {
    batchId?: string;
}

export enum MessageAuditAuditType {
    Resubmit = "resubmit",
    ResubmitWithChanges = "resubmitWithChanges",
    Skip = "skip",
    Retry = "retry",
}

export class MessageContent implements IMessageContent {
    eventContent?: EventContent;
    errorContent?: ErrorContent;

    constructor(data?: IMessageContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventContent = _data["eventContent"] ? EventContent.fromJS(_data["eventContent"]) : <any>undefined;
            this.errorContent = _data["errorContent"] ? ErrorContent.fromJS(_data["errorContent"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MessageContent {
        data = typeof data === 'object' ? data : {};
        let result = new MessageContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventContent"] = this.eventContent ? this.eventContent.toJSON() : <any>undefined;
        data["errorContent"] = this.errorContent ? this.errorContent.toJSON() : <any>undefined;
        return data;
    }

    clone(): MessageContent {
        const json = this.toJSON();
        let result = new MessageContent();
        result.init(json);
        return result;
    }
}

export interface IMessageContent {
    eventContent?: EventContent;
    errorContent?: ErrorContent;
}

export enum ResolutionStatus {
    Pending = "Pending",
    Deferred = "Deferred",
    Failed = "Failed",
    Resolved = "Resolved",
    DeadLettered = "DeadLettered",
    Unsupported = "Unsupported",
    Completed = "Completed",
    Skipped = "Skipped",
}

export class EventContent implements IEventContent {
    eventTypeId?: string;
    eventJson?: string;

    constructor(data?: IEventContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventTypeId = _data["eventTypeId"];
            this.eventJson = _data["eventJson"];
        }
    }

    static fromJS(data: any): EventContent {
        data = typeof data === 'object' ? data : {};
        let result = new EventContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventTypeId"] = this.eventTypeId;
        data["eventJson"] = this.eventJson;
        return data;
    }

    clone(): EventContent {
        const json = this.toJSON();
        let result = new EventContent();
        result.init(json);
        return result;
    }
}

export interface IEventContent {
    eventTypeId?: string;
    eventJson?: string;
}

export class ErrorContent implements IErrorContent {
    errorText?: string;
    errorType?: string;
    exceptionStackTrace?: string;
    exceptionSource?: string;

    constructor(data?: IErrorContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorText = _data["errorText"];
            this.errorType = _data["errorType"];
            this.exceptionStackTrace = _data["exceptionStackTrace"];
            this.exceptionSource = _data["exceptionSource"];
        }
    }

    static fromJS(data: any): ErrorContent {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorText"] = this.errorText;
        data["errorType"] = this.errorType;
        data["exceptionStackTrace"] = this.exceptionStackTrace;
        data["exceptionSource"] = this.exceptionSource;
        return data;
    }

    clone(): ErrorContent {
        const json = this.toJSON();
        let result = new ErrorContent();
        result.init(json);
        return result;
    }
}

export interface IErrorContent {
    errorText?: string;
    errorType?: string;
    exceptionStackTrace?: string;
    exceptionSource?: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}

export const CookieAuth = () =>
  new AuthClient(
    `https://${window.location.hostname}:${window.location.port ?? ""}`,
    undefined
  );