# BH.DIS.WebApp

HTTP API + Client for managing and interacting with DIS events

## Running locally

### First run
On first run, there are (potentially) two dev certificates that need to be trusted.

1. Default ASP.NET Core devcert (should only be necessary if first time running an ASP.NET core app on the machine)
2. Webpack dev server certificate, which allows for hot module reload of the front end code while developing

For trusting the ASP.NET Core devcert, [read here.](https://docs.microsoft.com/en-us/aspnet/core/getting-started/?view=aspnetcore-3.1&tabs=windows#trust-the-development-certificate)

For the webpack dev server certificate, you can either generate your own, or trust the one provided in the repo (`devcert.pfx`).

To generate your own, run:

```bash
openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 10000 -nodes
openssl pkcs12 -export -out devcert.pfx -inkey key.pem -in cert.pem
```

In either case, you can trust the certificate by launching the webpack dev server:

```
npm run start
```

Navigating to https://localhost:3001 in your browser and choosing to trust the certificate.

Lastly, you'll need to specify the following settings in your appsettings.json or user secrets file for the project:

`AzureWebJobsServiceBus` : A connection string to the Azure Service Bus for the DIS environment.

`MessageStoreStorageConnection` : A connection string to the azure storage account to use as the MessageStore.

#### Importing certificates in Chrome
To import the certificate in Chrome you must open Chrome and navigate to Settings. 
In Settings navigate to the "Pricacy and security" section and click on Security.
Within Security you must nagivate and click on "Manage certificates" and a window will pop up.
In the window you must select the tab named "Trusted Root Certification Authorities" and click import.
Walk through the importing process and select the file named devcert.crt within the ClientApp folder. Click Yes to any windows that might pop up in this process.

### Subsequent runs

Launch the WebApp project as normal.

If working on the front-end of the app, also launch the webpack-dev-server via `npm run start`. This will enable HMR.


## Adding endpoints

The project uses a specification-first approach. The specification lives in `api-spec.yaml`, which is an
Open API Specification v3 file. Add your endpoint and any model definitions to this file with your OAS editor of choice.

On every build, the `api-spec.yaml` file is read and both server-side code and client-side code is automatically generated
via `nswag`. The settings for configuring how the codegen works lives in the file `api-gen.nswag`.

Client-side code is written into `ClientApp/src/api-client/index.ts` and provides an SDK for easily calling the API.

Server-side code is written into `Controllers/ApiContract.g.cs`, which contains all the types, interfaces and controller code.
To implement the controller methods, create or update the `Controllers/ApiContract/<Tag>Implementation.cs` that corresponds to
your endpoint.

This Implementation will get dependency injected and called from within the autogenerated controller.

## Working on the front-end

The web application front-end is written in with [React](https://reactjs.org/) as the view library, with [Razzle](https://github.com/jaredpalmer/razzle)
for Server-Side Rendering. It uses [chakra-ui](https://chakra-ui.com/getting-started) as the component framework,
 and handles styling via CSS-in-JS using [emotion](https://emotion.sh/docs/introduction).

Top level components ('pages') are designed to be able to accept props passed to them from the server-side controllers,
but can also retrieve data from the server via the autogenerated api-client.

Calling the api, connecting to a signalr hub, or doing other forms of IO should be done in later lifecycle methods of the component,
such as `componentDidMount`, so that they happen client side and not server side. 
